---
title: Handling API request concurrency issues in React
author: SÃ©bastien Lorber
date: 2019-08-25
hero: ./images/hero.png
excerpt: Or how to avoid rendering the wrong data
---

Many blog articles talk about loading data in React apps, weither it's ad-hoc using `componentDidMount/update` or `useEffect`, through Redux, Apollo or another lib...

Yet, all those articles are **generally optimistic**, and never mention something important to consider: concurrency issues could happen, your UI may end up in an **inconsistant state**.

This post is not about request concurrency issues in general, but only those related to loading data in React applications.

An image is worth a thousand words:

![](./images/trump-macron.png)

If there is a non-null probability that your UI end up in such a state, your app is subject to concurrency issues.

## Why this happens?

Sometimes, the UI end up having multiple requests being loading in parallel, and we just assume that the list fired request will resolve last. Actually, it may resolve first, or may just fail, leading to a former pending request being the last one to resolve.

It happens more often than you think. For some apps, it can lead to very serious problems, like **an user buying the wrong product**, or **a doctor prescribing the wrong drug to a patient**.

A non-exhaustive list of reasons:

- The network is slow, bad, unpredictable, with variable request latencies...
- The backend is under heavy load, throttling some requests, under a Denial of Service attack...
- The user is clicking fast, commuting, travelling, on the country side...
- You are just unlucky

Developers don't see them in development, where the network conditions are generally good, sometimes running the backend API on your own computer, with close to 0ms latency.

In this post, I'll try to demonstrate that those issues do, with simple but realistic network simulations and runnable demos.

I'll also explain how you can fix those issues in many different ways, without requiring a large refactor.

## The incriminated code:

You probably already read tutorials with the following code:

```jsx
const StarwarsHero = ({ id }) => {
  const [data, setData] = useState(null);

  useEffect(() => {
    setData(null);
    fetchStarwarsHeroData(id).then(
      result => setData(result),
      e => console.warn('fetch failure', e),
    );
  }, [id]);

  return <div>{data ? data.name : <Spinner />}</div>;
};
```

Eventually, it will also ensure to not set state after unmount, and avoid the React warning (not really the subject of this article):

```jsx
const useIsMounted = () => {
  const isMounted = React.useRef(true);
  useEffect(() => {
    return () => (isMounted.current = false);
  });
  return isMounted;
};

const StarwarsHero = ({ id }) => {
  const [data, setData] = useState(null);
  const isMounted = useIsMounted();

  useEffect(() => {
    setData(null);
    fetchStarwarsHeroData(id).then(
      result => isMounted.current && setData(result),
      e => console.warn('fetch failure', e),
    );
  }, [id]);

  return <div>{data ? data.name : <Spinner />}</div>;
};
```

Or with the React class API:

```jsx
class StarwarsHero extends React.Component {
  state = { data: null };

  fetchData = id => {
    fetchStarwarsHeroData(id).then(
      result => isMounted.current && setData(result),
      e => console.warn('fetch failure', e),
    );
  };

  componentDidMount() {
    this.fetchData(this.props.id);
  }

  componentDidUpdate(nextProps) {
    if (nextProps.id !== this.props.id) {
      this.fetchData(this.props.id);
    }
  }

  componentWillUnmount() {
    this.setState = () => {}; // I bet you didn't know this trick ;)
  }

  render() {
    const { data } = this.state;
    return <div>{data ? data.name : <Spinner />}</div>;
  }
}
```

Here is a "Starwars Slider" demo running the code above. All 3 versions lead to the same result.

import { StarwarsHeroBaseSlider } from './components';

<StarwarsHeroBaseSlider />

When clicking fast on the arrows, even with your own good home network, you can already see something is wrong.

Now let's see what happens when you are in a train with a few tunnels.

## Simulating bad network conditions
