---
title: Handling API request concurrency issues in React
author: SÃ©bastien Lorber
date: 2019-08-25
hero: ./images/hero.png
excerpt: Or how to avoid rendering the wrong data
---

Many blog articles talk about loading data in React apps, weither it's ad-hoc using `componentDidMount/update` or `useEffect`, through Redux, Apollo or another lib...

Yet, all those articles are **generally optimistic**, and never mention something important to consider: concurrency issues could happen, your UI may end up in an **inconsistant state**.

This post is not about request concurrency issues in general, but only those related to loading data in React applications.

An image is worth a thousand words:

![](./images/trump-macron.png)

If there is a non-null probability that your UI end up in such a state, your app is subject to concurrency issues.

## How this may happen?

You might think that those issues can be ignored, because they do not happen often, and the case above does not seem so serious.

I think those issues actually happen more often than you think in the wild, and can lead to serious issues, like an user buying the wrong product, or a doctor prescribing the wrong drug to a patient.

Those issues generally arise when:
- The network is slow, unpredictable, with variable request latencies...
- The backend is under heavy load, throttling some requests, under a Denial of Service attack...
- The user is clicking fast
- You are just unlucky

Developers don't see them in development, where you likely have good network conditions, sometimes running the backend API on your own computer with close to 0ms latency.

In this post, I'll try to demonstrate that those issues happen more than we think, with simple but realistic network simulations and runnable demos.

I'll also explain how you can fix those issues in many different ways, without requiring a large refactor.


## The incriminated code:

You probably already read tutorials with the following code:

```jsx
const StarwarsHero = ({ id }) => {
  const [data, setData] = useState(null);
  useEffect(() => {
    setData(null);
    fetchStarwarsHeroData(id).then(
      result => setData(result),
      e => console.warn('fetch failure', e),
    );
  }, [id]);
  return <div>render data here</div>;
};
```

Eventually, it will also ensure to not set state after unmount, and avoid the React warning, using a ref, but it's not really the subject of this article.

```jsx
const useIsMounted = () => {
  const isMounted = React.useRef(true);
  useEffect(() => {
    return () => (isMounted.current = false);
  });
  return isMounted;
};

const StarwarsHero = ({ id }) => {
  const [data, setData] = useState(null);
  const isMounted = useIsMounted();
  useEffect(() => {
    setData(null);
    fetchStarwarsHeroData(id).then(
      result => isMounted.current && setData(result),
      e => console.warn('fetch failure', e),
    );
  }, [id]);
  return <div>render data here</div>;
};
```

You'll find also the same mistake using the React class API (in which it's also often forgotten to implement properly `componentDidUpdate` to refetch on id change).


Here is a "Starwars Slider" demo running the code above:


import { StarwarsHeroBaseSlider } from './components';

<StarwarsHeroBaseSlider />

Here, even with your own network, you can already see something is wrong.

Now let's see what happens when you are in a train with some tunnels.


## Simulating bad network conditions




