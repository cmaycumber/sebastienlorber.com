---
title: Records & Tuples for React
slug: records-and-tuples-for-react
author: SÃ©bastien Lorber
date: 2020-07-27
excerpt: ...how this JS proposal will impact your React codebase.
secret: true
---

Records & Tuples is a very interesting [proposal](https://github.com/tc39/proposal-record-tuple) for the JavaScript language, that just reached [stage 2](https://twitter.com/robpalmer2/status/1286040041089904640) at TC39.

A whole category of React bugs are related to **unstable object identities**:

- **Performance**: can trigger re-renders that could be avoided
- **Behavior**: can trigger useless effect re-executions, and lead to infinite loops
- **API surface**: we don't have a way to express when a stable object identity matters

In this article, I want to show you how **Records & Tuples** can solve these problems, with **pragmatic examples**, found in **real world React code-bases**.

---

# Records & Tuples 101

This article is about Records & Tuples **for React**. I'll only cover the basics here.

They looks like regular Objects and Arrays, with a **#** prefix.

```jsx
const record = #{a: 1, b: 2};

const updatedRecord = #{...record, b: 3};
// #{a: 1, b: 3};

const tuple = #[1, 2, 3, 4];

const filteredTuple = tuple.filter(num => num > 2)
// #[3, 4];
```

They are **deeply immutable** by default.

```jsx
const record = #{a: 1, b: 2};

record.b = 3;
// throws TypeError
```

They can be seen as **"compound primitives"**, and can be compared by value.

**VERY IMPORTANT**: two deeply equal records will **ALWAYS** have the same identity.

```jsx
{a: 1, b: [3, 4]} === {a: 1, b: [3, 4]}
// with objects => false

#{a: 1, b: #[3, 4]} === #{a: 1, b: #[3, 4]}
// with records => true
```

They are interoperable with JSON:

```jsx
const record = JSON.parseImmutable('{a: 1, b: [2, 3]}');
// #{a: 1, b: #[2, 3]}

JSON.stringify(record);
// '{a: 1, b: [2, 3]}'
```

They can only contain other records and tuples, or primitive values.

```jsx
const record = #{
  a: 1,
  b: new Date(),
  c: new MyClass()
};
// throws TypeError
```

Want more? Read the [proposal](https://github.com/tc39/proposal-record-tuple) directly, or this [article](https://2ality.com/2020/05/records-tuples-first-look.html) from Axel Rauschmayer.

---

# Records & Tuples for React

React developers are now used to **immutability**.
Every time you update some piece of state in an immutable way, you create **new object identities**.

But this immutability model has introduced a whole new class of bugs, and performance issues in React applications.
Sometimes, a component works correctly and in a performant way, only under the assumption that props preserve identities as most as they can over time.

I like to think about Records & Tuples as a convenient **way to make object identities more "stable"**.

Let's see how this proposal will impact your React code with practical use cases.

### Immutability

Enforcing immutability can be achieved with `Object.freeze()` applied recursively.

But in practice, we often use the immutability model without enforcing it too strictly, as it's not convenient to apply `Object.freeze()` after each update. Yet, mutating the React state directly is a common mistake for new React developers.

The Records & Tuples proposal will enforce immutability, and prevent state mutation mistakes:

```jsx
const Hello = ({profile}) => {

   // prop mutation: throws TypeError
   profile.name = "Sebastien updated" // throws TypeError

   return <p>Hello {profile.name}</p>;
}

function App() {
   const [profile, setProfile] = React.useState(#{ name: "Sebastien" });

   // state mutation: throws TypeError
   profile.name = "Sebastien updated" // throws TypeError

   return <Hello profile={profile}/>
}
```

### Immutable updates

There are many ways to perform immutable state updates in React: vanilla JS, Lodash's set, ImmerJS, ImmutableJS (check [my article](https://dev.to/sebastienlorber/insight-3-use-immerjs-over-lodash-set-immutablejs-or-plain-js-36bl).

I think it's safe to say that [ImmerJS](https://github.com/immerjs/immer) has won this battle, due to its simplicity and interoperability with regular JS code.

Michael Weststrate (author of ImmerJS), has [highlighted](https://twitter.com/mweststrate/status/1263482177934819329) that Records & Tuples can be updated deeply without requiring a third-party library like ImmerJS:

```jsx
const initialState = #{
    counters: #[
        #{ name: "Counter 1", value: 1 },
        #{ name: "Counter 2", value: 0 },
        #{ name: "Counter 3", value: 123 },
    ],
    metadata: #{
        lastUpdate: 1584382969000,
    },
};

const updatedState = #{
    ...initialState,
    counters[0].value: 2,
    counters[1].value: 1,
    metadata.lastUpdate: 1584383011300,
};
```

This is part of a [separate proposal](https://github.com/tc39/proposal-deep-path-properties-for-record), currently at stage 1.

### useMemo

In addition to memoizing expensive computations, `useMemo()` is also useful to avoid creating new object identities, that might trigger useless computations, re-renders, or effects executions deeper in the tree.

I will illustrate this with a common use-case: you have an UI with multiple filters, and want to fetch some data from the backend.

Existing React code-bases might contain code such as:

```jsx
// Don't change apiFilters object identity, unless one of the filter changes
// Not doing this is likely to trigger a new fetch on each render
const apiFilters = useMemo(
  () => ({ userFilter, companyFilter }),
  [userFilter, companyFilter],
);

const { apiData, loading } = useApiData(apiFilters);
```

With Records & Tuples, this becomes simply:

```jsx
const {apiData,loading} = useApiData(#{ userFilter, companyFilter })
```

### useEffect

Let's continue with our api filters use-case.

```jsx
const apiFilters = { userFilter, companyFilter };

useEffect(() => {
  fetchApiData(apiFilters).then(setApiDataInState);
}, [apiFilters]);
```

This code has a mistake: the identity of the `apiFilters` object changes everytime this component re-renders, the effect gets re-executed.

If you are unlucky, `setApiDataInState` will actually trigger a re-render, and you will end up with an infinite fetch/render loop.

This mistake is so common across React developers that there are thousand of Google search results for [useEffect + "infinite loop"](https://www.google.com/search?q=useEffect+%2B+%22infinite+loop%22).
Kent C Dodds even created [a tool](https://github.com/kentcdodds/stop-runaway-react-effects) to break this kind of infinite loop in development.

A common solution is to create the final `apiFilters` directly in the effect's callback:

```jsx
useEffect(() => {
  const apiFilters = { userFilter, companyFilter };
  fetchApiData(apiFilters).then(setApiDataInState);
}, [userFilter, companyFilter]);
```

More creative (and not very performant), this one uses JSON parse/stringify ([source](https://twitter.com/acutmore/status/1256533631914426369)) :

```jsx
const apiFilters = { userFilter, companyFilter };

const apiFiltersString = JSON.stringify(apiFilters);

useEffect(() => {
  fetchApiData(JSON.parse(apiFiltersString)).then(
    setApiDataInState,
  );
}, [apiFiltersString]);
```

The one I like the most:

```jsx
// We already saw this somewhere, right? :p
const apiFilters = useMemo(() => ({ userFilter, companyFilter }),[userFilter, companyFilter];

useEffect(() => {
  fetchApiData(apiFilters).then(setApiDataInState);
}, [apiFilters]);
```

There are probably many fancy ways to solve this problem, but they tend to all become annoying, as the number of filters increase, and they are much less idiomatic to their Records & Tuples counterpart:

```jsx
const apiFilters = #{ userFilter, companyFilter };

useEffect(() => {
  fetchApiData(apiFilters).then(setApiDataInState);
}, [apiFilters]);
```

### Props and React.memo

Preserving object identities in props is also very useful for React performances.

```jsx
const Parent = () => {
  // will trigger re-renders
  useRenderEverySeconds();

  return (
    <ExpensiveChild
      // someData props object is created "on the fly"
      someData={{ attribute1: 'abc', attr2: 'def' }}
    />
  );
};

const ExpensiveChild = React.memo(({ someData }) => {
  return <div>{expensiveRender(someData)}</div>;
});
```

Another very common mistake is to create new objects in the render method.
Most of the time, this is not a problem, and React is fast enough.

But sometimes you are looking to optimize your app, and this new object creating makes the `React.memo()` useless. Worst, it actually makes your application a little bit slower (as it now have to run a shallow equality check).

One pattern I see very often in client code-bases, is to do so on context providers:

```jsx
<MyAppContext.Provider
  value={{ currentUser, currentCompany }}
/>
```

Despite the fact that `currentUser` or `currentCompany` never gets updated, your context value changes every time this provider re-renders, which trigger re-renders of all subscribers.

All these issues can be solved with memoization:

```jsx
const Parent = () => {
  // will trigger re-renders
  useRenderEverySeconds();

  const someData = useMemo(
    () => ({ attribute1: 'abc', attr2: 'def' }),
    [],
  );

  return <ExpensiveChild someData={someData} />;
};
```

```jsx
const contextValue = useMemo(
  () => ({ currentUser, currentCompany }),
  [currentUser, currentCompany],
);

<MyAppContext.Provider value={contextValue} />;
```

The current state of React is that it is way too easy to opt-out of your own optimisations.

With Records & Tuples, it becomes idiomatic to write performant code:

```jsx
const Parent = () => {
  // will trigger re-renders
  useRenderEverySeconds();

  return <ExpensiveChild someData={#{ attribute1: 'abc', attr2: 'def' }} />;
};
```

```jsx

<MyAppContext.Provider value={#{ currentUser, currentCompany }} />;
```

### Fetching and re-fetching

You can fetch data in many ways in React: `useEffect`, HOC, Render props, Redux, SWR, React-Query, Apollo, Relay, Urql, ...

They all share something in common: at some point you hit your backend with a request, and generally get some JSON data as a result.

By chance, JSON is compatible with Records & Tuples. There's a [JSON.parseImmutable](https://github.com/tc39/proposal-record-tuple#jsonparseimmutable) function, and you can convert an object to a record with `Record(obj)`, so you should be able to convert any backend response to a Record.

To illustrate this section, I will use [react-async-hook](https://github.com/slorber/react-async-hook), my own very simple fetching library, but all this applies to other libraries as well.

Let's consider a classic async function to get some API data:

```jsx
const fetchUserAndCompany = async () => {
  const response = await fetch(
    `https://myBackend.com/userAndCompany`,
  );
  return response.json();
};
```

Now let's consider an app that fetch the data, and tries to ensure this data is stays "fresh" over time:

```jsx
const App = ({ id }) => {
  const { result, refetch } = useAsync(
    fetchUserAndCompany,
    [],
  );

  // We try very hard to not display stale data to the user!
  useInterval(refetch, 10000);
  useOnReconnect(refetch);
  useOnNavigate(refetch);

  if (!result) {
    return null;
  }

  return (
    <div>
      <User user={result.user} />
      <Company company={result.company} />
    </div>
  );
};

const User = React.memo(({ user }) => {
  return <div>{user.name}</div>;
});

const Company = React.memo(({ company }) => {
  return <div>{company.name}</div>;
});
```

There is a problem: you have used `React.memo` for performance reasons, but every time the re-fetch happens, you end up with a new JS object, with a new identity, and everything re-renders.

Let's convert the fetch function to return a Record instead:

```jsx
const fetchUserAndCompany = async () => {
  const response = await fetch(
    `https://myBackend.com/userAndCompany`,
  );
  return Record(await response.json());
};
```

With Records & Tuples, if you re-fetch and the backend returns the exact same response, you don't re-render anything at all!

Also, if only one part of the response has changed, the other nested objects of the response will still keep their identity. This means that if only `user.name` changed, the `User` component will re-render, but not the `Company` component!

I let you imagine the performance impact of all this, considering re-fetching and patterns like "Stale-While-Revalidate" are becoming increasingly popular, and provided out of the box by libraries such as SWR, React-Query, Apollo, Relay...

## Reading query strings

If you create a search UI in React, you probably know it's a good practice to preserve the state of the filters in the querystring. This makes it possible for the user to can copy/paste the link to someone else, refresh the page, or bookmark it.

If you have 1 or 2 filters, that's simple, but as soon as your search UI becomes complex (10+ filters, ability to compose queries with AND/OR logic...), you'd better use a library to parse/stringify your filters.

I personally like [qs](https://github.com/ljharb/qs), as it's one of the few libraries that is able to handle nested filter objects.

```jsx
const queryStringObject = {
  filters: {
    userName: 'Sebastien',
  },
  displayMode: 'list',
};

const queryString = qs.stringify(queryStringObject);

const queryStringObject2 = qs.parse(queryString);

assert.deepEqual(queryStringObject, queryStringObject2);
```

You can integrate the querystring parsing in a hook.

```jsx
const useQueryStringObject = () => {
  const { search } = useLocation(); // Provided by your routing library
  return useMemo(() => qs.parse(search), [search]);
};
```

Now, imagine that deeper in the tree you have:

```js
const { filters } = useQueryStringObject();

useEffect(() => {
  fetchUsers(filters);
}, [filters]);
```

This is a bit nasty here, but the same problem happens again and again.

Despite the usage of `useMemo()` to try to preserve `queryStringObject`, you will end up again with unwanted fetches.

When the user will update the `displayMode` (that should change the rendering logic, not trigger a refetch), the querystring will change, leading to the querystring being parsed again, leading to a new object identity for the `filter` attribute, leading to the unwanted `useEffect` execution.

Again, Records & Tuples would prevent such things to happen.

````
```jsx
const useQueryStringRecord = () => {
  const { search } = useLocation();
  return useMemo(() => Record(qs.parse(search)), [search]);
};
````

Now, if the user updates the `displayMode`, the `filter` will still preserve its identity, and will not trigger an useless fetch.

### Deeply equal JS transformations

Imagine the following JS transformation in a component:

```jsx
const AllUsers = [
  { id: 1, name: 'Sebastien' },
  { id: 2, name: 'John' },
];

const Parent = () => {
  const userIdsToHide = useUserIdsToHide();
  const users = AllUsers.filter(
    (user) => !userIdsToHide.includes(user.id),
  );
  return <UserList users={users} />;
};

const UserList = React.memo(({ users }) => (
  <ul>
    {users.map((user) => (
      <li key={user.id}>{user.name}</li>
    ))}
  </ul>
));
```

Every time the `Parent` component re-renders, the `UserList` component re-render as well, because `filter` will always return a new array instance.

This is the case even if `userIdsToHide` is empty! In such case, filter operation does not actually filter anything, it just creates useless array instances, opting out of our `React.memo` optimisations.

These kind of transformations are very common in React codebase, with operators sur as `map` or `filter`, in components, reducers, selectors, Redux...

Again, we can solve this by using memoization, but it's much more idiomatic to just use Records & Tuples:

```jsx
const AllUsers = #[
  #{ id: 1, name: 'Sebastien' },
  #{ id: 2, name: 'John' },
];

const filteredUsers = AllUsers.filter(() => true);

AllUsers === filteredUsers;
// true
```

### Serialization guarantee

If you are an architect and use Redux, you might want to ensure that people don't put unserializable things in the global state. This is particularly important if you plan to send the state to the backend, or persist it locally in `localStorage` (or `AsyncStorage` for ReactNative users).

To ensure that, you just need to ensure that the root objects are records. This will guarantee that all the nested attributes are also records, and thus always serializable.

Here's an example integration with Redux. This ensure your whole Redux store keeps being serializable over time:

```jsx
if (process.env.NODE_ENV === 'development') {
  ReduxStore.subscribe(() => {
    if (typeof ReduxStore.getState() !== 'record') {
      throw new Error(
        "Don't put non-serializable things in the Redux store!!!",
      );
    }
  });
}
```

### Explicit API surface for object identities

Let's consider this TypeScript component:

```tsx
const UsersPageContent = ({
  usersFilters,
}: {
  usersFilters: UsersFilters;
}) => {
  const [users, setUsers] = useState([]);

  // poor-man's fetch
  useEffect(() => {
    fetchUsers(usersFilters).then(setUsers);
  }, [usersFilters]);

  return <Users users={users} />;
};
```

This code may or may not create an infinite loop, as we have seen already, depending on how stable the usersFilters prop is. This creates an implicit API contract that should be documented and clearly understood by the implementor of the parent component, and despite using TypeScript, this is not reflected in the type-system.

The following will lead to an infinite loop, but TypeScript has no way to prevent this:

```tsx
<UsersPageContent
  usersFilters={{ nameFilter, ageFilter, companyFilter }}
/>
```

Now, with Records & Tuples, we should be able to tell TypeScript to expect a Record for the filter prop:

```tsx
const UsersPageContent = ({
  usersFilters,
}: {
  usersFilters: #UsersFilters;
}) => {};
```

And TypeScript will be able to show an error for:

```tsx
<UsersPageContent
  usersFilters={{ nameFilter, ageFilter, companyFilter }}
/>
```

While TypeScript would accept:

```tsx
<UsersPageContent
  usersFilters={#{ nameFilter, ageFilter, companyFilter }}
/>
```

With Records & Tuples, we have been able to prevent an infinite loop at compile time. Want

We have an explicit way to tell the compiler that our implementation is object-identity sensitive.

### CSS-in-JS performances

Let's consider some CSS-in-JS from a popular lib, using the css prop with object styles:

```jsx
<div
  css={{
    backgroundColor: 'hotpink',
  }}
>
  This has a hotpink background.
</div>
```

Your CSS-in-JS library receives a new CSS object on every re-render.

On first render, it will hash this object as a unique class name, and insert the CSS.
The style object has a different identity for each re-render, and the CSS-in-JS library have to hash it again and again.

```jsx
const insertedClassNames = new Set();

function handleStyleObject(styleObject) {
  // computeStyleHash re-executes every time
  const className = computeStyleHash(styleObject);

  // only insert the css for this className once
  if (!insertedClassNames.has(className)) {
    insertCSS(className, styleObject);
    insertedClassNames.add(className);
  }

  return className;
}
```

With Records & Tuples, the identity of such a style object is preserved over time.

```jsx
<div
  css={#{
    backgroundColor: 'hotpink',
  }}
>
  This has a hotpink background.
</div>
```

Records & Tuples can be used as [Map keys](https://github.com/tc39/proposal-record-tuple#usage-in-mapsetweakmapweakset), which could make the implementation of your CSS-in-JS faster:

```jsx
const insertedStyleRecords = new Map();

function handleStyleRecord(styleRecord) {
  let className = insertedStyleRecords.get(styleRecord);

  if (!className) {
    // computeStyleHash is only executed once!
    className = computeStyleHash(styleRecord);
    insertCSS(className, styleRecord);
    insertedStyleRecords.add(styleRecord, className);
  }

  return className;
}
```

A record will likely be more expensive to create than the equivalent JS objects, but I think it's safe to say it will be faster than creating the equivalent object, and then hashing it to a className.

Note: some CSS-in-JS library with a good babel plugin might be able to transform static style objects as constants at compilation time, but they will have a hard time doing so with dynamic styles.

```jsx
const staticStyleObject = { backgroundColor: 'hotpink' };

<div css={staticStyleObject}>
  This has a hotpink background.
</div>;
```

---

# Conclusion

Many React performance and behavior issues are currently related to object identities

**Records & Tuples** will ensure that identities are "more stable" out of the box, by providing some kind of **"automatic memoization"**.

Also, TypeScript will permit to express better that your API / Component expect stable identities.

I hope you are now as much excited by this proposal than I am.

Thank you for reading!

---

If you like it, spread the word with a [Retweet]()

Browser code demos, or correct my post typos [on the blog repo](https://github.com/slorber/sebastienlorber.com/tree/master/content/posts/2020-04-21-using-expo-and-gatsby-together)

For more content like this, subscribe to [my mailing list](https://mailchi.mp/4ea4df0b54f7/sebastienlorber) and follow me on [Twitter](https://twitter.com/sebastienlorber).
